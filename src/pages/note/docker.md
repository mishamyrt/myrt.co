---
layout: ../../layouts/note.astro
title: Да кто такой этот ваш Docker?
client: Self
published_at: 2021-07-25 00:00:00
description: |
  We built an unofficial Mars Rover Landing site in celebration of NASA’s Perseverance Rover.
---

Я опять хочу рассказть про то, про что точно слышали все, но не все до конца понимают как это работает. Итак — Docker

## Что такое докер?

Docker — это система контейнеризации. Важно, что именно контейниризации, а не виртуализации. Разница заключается в том, что контейнер использует предоставленное системой ядро, а не запускает своё. Правда существует KVM контейнеризация, которая тоже использует хостовое ядро и на этом месте я запутался в терминах.

## Что такое контейнер?

В целом, виртуализация позволяет достичь гораздо большей степени изоляции. Причины использовать виртуализацию:

- Используется специфичное оборудование, для запуска которого нужны модули ядра.
- Задействованы функции, которые не активированы в хостовом ядре (config_high_memory)
- Использование монолитного ядра без догрузки модулей
- Безопасность выше

Но за эти возможности приходится дорого платить: 

- Размер (полноценная ОС)
- Время старта
- Долгое время установки
- Потребление ресурсов

Получается, что если нам не нужна адская изоляция и тестовые ядра, мы можем обеспечить безопасность нашего приложения, то мы можем избежать оверхэд и использовать контейнер.

## Специфика

Окей, вы примерно поняли почему контейнеры в большинстве ситуаций круче чем выделенная виртуалка, пришло время внести ложку дёгтя: описанная схема контейнеризации актуальная только для Linux. В macOS и Windows docker поднимает полноценную виртуальную машину, поверх которой уже запускаются контейнеры.

Это конечно не так эффективно как чистые контейнеры, но если вам нужно запустить десяток сервисов, то одна виртуалку будет всяко выгоднее чем 10.

В Windows есть возможность запускать нативные windows–контейнеры, в которых в качестве среды исполнения будет использоваться Windows, а не Линукс, но это очень редко используемая фича, в реальной жизни мне пока не приходилось с ней сталкиваться.

## Слои

Что объединяет эти картинки? Из слоёв состоит тесто, огры и контейнеры.

Контейнер хранит в себе слоёный пирог из модификаций файловой системы, которые накладываются на базовый образ. Базовый образ в Docker называется scratch

![asd](/blog/docker/layers@2x.png)

К слову, важно различать образ и контейнер. Образ является образцом, на основе которого создаётся контейнер.

Итак, как выглядит образ изнутри

Это образ `node:alpine` Который повсеместно используется для запуска Node.JS приложений. 

На первом этапе берётся базовый образ. В данном случае это alpine, минималистичный линукс–дистрибутив.

Затем к нему докидываются файлы и настройки, необходимые для работы ноды.

Потом устанавливается и настраивается Yarn.

Последним шагом копируется Entrypoint. Это файл, который будет выполняентся по умолчанию. Его можно перекрыть, если запустить контейнер через команду

## Имутабельность и вольюмы

Важной концепцией в контейнерах является их имутабельность. Они создаются из образа и имеют в  воей системе те файлы, которые были а момент сборки. Для сохранения состояния принято использовать вольюмы. Вольюм — дыра, через которую контейнерезированное приложение видит файлы на хостовой ОС. Они описываются в формате <путь в контейнере>:<путь на хосте>.

Самая частая схема использования вольюмов, которую я видел, это когда есть контейнер с бэкэндом, который не меняется во время выполнения. Вместо этого, он по внутренней Docker–сети обращается к контейнеру с базой, например postgres, который в свою очередь пишет данные в хранилище, которое прокинуто в вольюм.

## Оркестраторы

Оркестратор — приложение которое позволяет управлять большим количеством контейнеров одновременно. Два самых крупных и общепризнанных оркестратор — docker-compose и kubernetes.

Кубер нужен для управления сложными системами. он позволяет выстроить схему, где есть одна руководящая master-нода и несколько слейв–нод, которые подчиняются ей. Кубер умеет решать вопросы шардирования, распределения данных, прокидывания облачных хранилищ и ещё кучю всего.

Из–за высокого порога вхождения он редко используется программистами, чаще девопс–инженерами.

 compose же умеет гораздо меньше и поэтому гораздо проще в освоении. Он позволяет в одном файле описать связку контейнеров, которые будут взаимодействовать между собой и с внешним миром.

## Демо

.editorconfig

```jsx
[*]
indent_style = space
indent_size = 2
```

`backend/`

index.js:

```jsx
const http = require('http');

const host = '0.0.0.0';
const port = 80;

http
  .createServer((req, res) => {
    res.writeHead(200);
    res.end(`Request to ${req.url} was successful\n`);
  })
  .listen(port, host, () =>
    console.log(`http://${host}:${port}`)
  )
```

Dockerfile:

```yaml
FROM node:alpine

WORKDIR /usr/src/app
COPY . .
EXPOSE 80
CMD [ "node", "index.js" ]
```

`proxy/`

nginx.conf

```jsx
server {
  listen 80;

  access_log /dev/stdout;
  error_log /dev/stdout info;

  location /api/ {
    proxy_pass  http://backend:80/;
  } 
}
```

Dockerfile

```jsx
FROM nginx:alpine
COPY nginx.conf /etc/nginx/conf.d/default.conf
```

docker-compose.yaml

```yaml
services:
  backend:
    build: ./backend/
    networks:
      - bridge
  proxy:
    build: ./proxy/
    ports:
      - "8080:80"
    networks:
      - bridge
networks:
  default:
  bridge:
    driver: bridge
```

Запуск

```bash
docker compose up --build
```